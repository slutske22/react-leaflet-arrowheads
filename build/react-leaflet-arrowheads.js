(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("leaflet"), require("react"), require("react-leaflet"));
	else if(typeof define === 'function' && define.amd)
		define([, , ], factory);
	else if(typeof exports === 'object')
		exports["ReactLeafletArrowheads"] = factory(require("leaflet"), require("react"), require("react-leaflet"));
	else
		root["ReactLeafletArrowheads"] = factory(root["L"], root["React"], root[undefined]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_leaflet__, __WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_leaflet__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/react-leaflet-arrowheads.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/leaflet-arrowheads/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/leaflet-arrowheads/src/index.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var leaflet_geometryutil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet-geometryutil */ \"./node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js\");\n/* harmony import */ var leaflet_geometryutil__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet_geometryutil__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _leaflet_arrowheads_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leaflet-arrowheads.js */ \"./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js\");\n/* harmony import */ var _leaflet_arrowheads_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_leaflet_arrowheads_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./node_modules/leaflet-arrowheads/src/index.js?");

/***/ }),

/***/ "./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js":
/*!*******************************************************************!*\
  !*** ./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nfunction modulus(i, n){\n   return (i % n + n) % n;\n}\n\n\nL.Polyline.include({\n\n   arrowheads: function(options = {}){\n\n      // Merge user input options with default options:\n      const defaults = {\n         yawn: 60,\n         size: '15%',\n         frequency: 'allvertices',\n         proportionalToTotal: false,\n      }\n\n      this.options.noClip = true;\n\n      let actualOptions = Object.assign({}, defaults, options)\n      this._arrowheadOptions = actualOptions;\n\n      this._hatsApplied = true;\n      return this;\n   },\n\n   buildVectorHats: function( options ){\n\n      // Reset variables from previous this._update()\n      if (this._arrowheads){\n         this._arrowheads.remove()\n      }\n\n      //  -------------------------------------------------------- //\n      //  ------------  FILTER THE OPTIONS ----------------------- //\n      /*\n         * The next 3 lines folds the options of the parent polyline into the default options for all polylines\n         * The options for the arrowhead are then folded in as well\n         * All options defined in parent polyline will be inherited by the arrowhead, unless otherwise specified in the arrowhead(options) call\n      */\n\n\n      let defaultOptionsOfParent = Object.getPrototypeOf(Object.getPrototypeOf(this.options))\n\n      // merge default options of parent polyline (this.options's prototype's prototype) with options passed to parent polyline (this.options).\n      let parentOptions = Object.assign({}, defaultOptionsOfParent, this.options)\n\n      // now merge in the options the user has put in the arrowhead call\n      let hatOptions = Object.assign({}, parentOptions, options)\n\n      // ...with a few exceptions:\n      hatOptions.smoothFactor = 1\n      hatOptions.fillOpacity = 1\n      hatOptions.fill = options.fill ? true : false\n      hatOptions.interactive = false\n\n      //  ------------  FILTER THE OPTIONS END -------------------- //\n      //  --------------------------------------------------------- //\n\n\n\n\n\n      //  --------------------------------------------------------- //\n      //  ------ LOOP THROUGH EACH POLYLINE SEGMENT --------------- //\n      //  ------ TO CALCULATE HAT SIZES AND CAPTURE IN ARRAY ------ //\n\n      let size = options.size.toString(); // stringify if its a number\n      let allhats = []; // empty array to receive hat polylines\n      const { frequency } = options;\n\n\n      this._parts.forEach( (peice, index) => {\n\n         // Immutable variables for each peice\n         const latlngs = peice.map( point => this._map.layerPointToLatLng(point));\n\n         const totalLength = ( () => {\n            let total = 0;\n            for (var i = 0; i < peice.length-1; i++) {\n               total += this._map.distance(latlngs[i], latlngs[i+1])\n            }\n            return total;\n         })();\n\n\n         // TBD by options if tree below\n         let derivedLatLngs;\n         let derivedBearings;\n         let spacing;\n         let noOfPoints;\n\n\n         //  Determining latlng and bearing arrays based on frequency choice:\n         if ( !isNaN(frequency) ) {\n\n            spacing = 1 / frequency;\n            noOfPoints = frequency;\n\n         } else if ( frequency.toString().slice( frequency.toString().length - 1, frequency.toString().length ) === '%' ){\n\n            console.log('Error: arrowhead frequency option cannot be given in percent.  Try another unit.');\n\n         } else if ( frequency.toString().slice( frequency.toString().length - 1, frequency.toString().length ) === 'm' ){\n\n            spacing = frequency.slice(0,frequency.length-1) / totalLength;\n            noOfPoints = 1 / spacing\n            // round things out for more even spacing:\n            noOfPoints = Math.floor(noOfPoints)\n            spacing = 1 / noOfPoints\n\n         } else if ( frequency.toString().slice( frequency.toString().length - 2, frequency.toString().length ) === 'px' ){\n\n            spacing = ( () => {\n\n               let chosenFrequency = frequency.slice(0,frequency.length-2)\n               let refPoint1 = this._map.getCenter()\n               let xy1 = this._map.latLngToLayerPoint( refPoint1 )\n               let xy2 = {\n                  x: xy1.x + Number(chosenFrequency),\n                  y: xy1.y\n               }\n               let refPoint2 = this._map.layerPointToLatLng( xy2 )\n               let derivedMeters = this._map.distance(refPoint1, refPoint2)\n               return derivedMeters / totalLength;\n            })()\n\n            noOfPoints = 1 / spacing\n\n            // round things out for more even spacing:\n            noOfPoints = Math.floor(noOfPoints)\n            spacing = 1 / noOfPoints\n\n\n         }\n\n\n         if (options.frequency === 'allvertices'){\n\n            derivedBearings = ( () => {\n               let bearings = [];\n               for (var i = 1; i < latlngs.length; i++) {\n                  let bearing = L.GeometryUtil.angle( this._map, \n                     latlngs[ modulus( (i-1), latlngs.length ) ], latlngs[i]\n                  ) + 180\n                  bearings.push(bearing)\n               }\n               return bearings;\n            })()\n\n            derivedLatLngs = latlngs\n            derivedLatLngs.shift()\n\n         } else if (options.frequency === 'endonly') {\n\n            derivedLatLngs = [\n               latlngs[latlngs.length - 1]\n            ];\n\n            derivedBearings = [\n               L.GeometryUtil.angle( this._map, \n                  latlngs[latlngs.length - 2], latlngs[latlngs.length - 1]\n               ) + 180\n            ];\n\n         } else {\n\n            derivedLatLngs = []\n            let interpolatedPoints = []\n            for (var i = 0; i < noOfPoints; i++) {\n\n               let interpolatedPoint = L.GeometryUtil.interpolateOnLine(\n                  this._map, latlngs, spacing * (i + 1)\n               )\n\n               interpolatedPoints.push(interpolatedPoint)\n               derivedLatLngs.push(interpolatedPoint.latLng)\n\n            }\n\n            derivedBearings = ( () => {\n               let bearings = [];\n\n               for (var i = 0; i < interpolatedPoints.length; i++) {\n                  let bearing = L.GeometryUtil.angle( this._map, \n                     interpolatedPoints[i].latLng, latlngs[ interpolatedPoints[i].predecessor ]\n                  )\n                  bearings.push(bearing)\n               }\n               return bearings;\n            })()\n\n         }\n\n\n         let n = latlngs.length - 1\n         let hats = [];\n\n         // Function to build hats based on index and a given hatsize in meters\n         const pushHats = (size) => {\n\n            let leftWingPoint =\n               L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] - options.yawn/2, size)\n\n            let rightWingPoint =\n               L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] + options.yawn/2, size)\n\n            let hatPoints = [\n                  [leftWingPoint.lat, leftWingPoint.lng],\n                  [derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n                  [rightWingPoint.lat, rightWingPoint.lng]\n               ]\n\n            let hat = options.fill\n               ? L.polygon(hatPoints, hatOptions)\n               : L.polyline(hatPoints, hatOptions)\n\n            hats.push(hat)\n\n         } // pushHats()\n\n\n         // Function to build hats based on pixel input\n         const pushHatsFromPixels = (size) => {\n\n            let sizePixels = size.slice(0, size.length-2)\n\n            let derivedXY = this._map.latLngToLayerPoint(derivedLatLngs[i])\n\n            let bearing = derivedBearings[i]\n\n            let thetaLeft = (180 - bearing - options.yawn/2) * (Math.PI / 180),\n               thetaRight = (180 -bearing + options.yawn/2) * (Math.PI / 180)\n\n            let dxLeft = sizePixels * Math.sin(thetaLeft),\n               dyLeft = sizePixels * Math.cos(thetaLeft),\n               dxRight =sizePixels * Math.sin(thetaRight),\n               dyRight =sizePixels * Math.cos(thetaRight)\n\n            let leftWingXY = {\n               x: derivedXY.x + dxLeft,\n               y: derivedXY.y + dyLeft\n            }\n            let rightWingXY = {\n               x: derivedXY.x + dxRight,\n               y: derivedXY.y + dyRight\n            }\n\n            let leftWingPoint = this._map.layerPointToLatLng(leftWingXY),\n               rightWingPoint = this._map.layerPointToLatLng(rightWingXY)\n\n            let hatPoints = [\n                  [leftWingPoint.lat, leftWingPoint.lng],\n                  [derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n                  [rightWingPoint.lat, rightWingPoint.lng]\n               ]\n\n            let hat = options.fill\n               ? L.polygon(hatPoints, hatOptions)\n               : L.polyline(hatPoints, hatOptions)\n\n            hats.push(hat)\n\n         } // pushHatsFromPixels()\n\n\n         //  -------  LOOP THROUGH POINTS IN EACH SEGMENT ---------- //\n         for (var i = 0; i < derivedLatLngs.length; i++) {\n\n            // ---- If size is chosen in meters -------------------------\n            if (size.slice(size.length-1, size.length) === 'm' ){\n\n               let hatSize = size.slice(0, size.length-1)\n               pushHats(hatSize)\n\n            // ---- If size is chosen in percent ------------------------\n            } else if (size.slice(size.length-1, size.length) === '%' ){\n\n               let sizePercent = size.slice(0, size.length-1)\n               let hatSize = ( () => {\n                  if (options.frequency === 'endonly' && options.proportionalToTotal){\n                     return totalLength * sizePercent / 100;\n                  } else {\n                     let averageDistance = ( totalLength / (peice.length-1) )\n                     return averageDistance * sizePercent / 100\n                  }\n               })() // hatsize calculation\n\n               pushHats( hatSize );\n\n            // ---- If size is chosen in pixels --------------------------\n            } else if ( size.slice(size.length-2, size.length) === 'px' ){\n\n               pushHatsFromPixels(options.size)\n\n            // ---- If size unit is not given -----------------------------\n            } else {\n\n               console.log(\n                  'Error: Arrowhead size unit not defined.  Check your arrowhead options.'\n               )\n\n            }  // if else block for Size\n\n\n         } // for loop for each point witin a peice\n\n         allhats.push(...hats);\n\n      }) // forEach peice\n\n      //  --------- LOOP THROUGH EACH POLYLINE END ---------------- //\n      //  --------------------------------------------------------- //\n\n\n      let arrowheads = L.layerGroup(allhats)\n      this._arrowheads = arrowheads;\n\n      return this\n\n   },\n\n\n   getArrowheads: function(){\n      if (this._arrowheads){\n         return this._arrowheads;\n      } else {\n         return console.log(`Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'`);\n      }\n   },\n\n   deleteArrowheads: function(){\n\n      if (this._arrowheads){\n         this._arrowheads.remove()\n         delete this._arrowheads;\n         delete this._arrowheadOptions;\n         this._hatsApplied = false;\n      }\n\n   },\n\n\n   addTo: function (map) {\n      map.addLayer(this);\n      if (this._hatsApplied){\n         this.buildVectorHats(this._arrowheadOptions);\n         this._arrowheads.addTo(this._map)\n      }\n      return this;\n   },\n\n\n   _update: function () {\n\t\tif (!this._map) { return; }\n\n      this._clipPoints();\n\t\tthis._simplifyPoints();\n\t\tthis._updatePath();\n\n\n      if (this._hatsApplied){\n         this.buildVectorHats(this._arrowheadOptions);\n         this._map.addLayer(this._arrowheads);\n      }\n\t},\n\n\n   remove: function () {\n\n      if (this._arrowheads){\n         this._arrowheads.remove();\n      }\n      return this.removeFrom(this._map || this._mapToAdd);\n   },\n\n\n})\n\n\n\nL.LayerGroup.include({\n\n   removeLayer: function (layer) {\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\n\n\t\tif (this._map && this._layers[id]) {\n         if (this._layers[id]._arrowheads){\n            this._layers[id]._arrowheads.remove() ;\n         }\n\t\t\tthis._map.removeLayer(this._layers[id]);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\treturn this;\n\t},\n\n\n   onRemove: function (map, layer) {\n\n      for (var layer in this._layers) {\n         if (this._layers[layer]){\n            this._layers[layer].remove()\n         }\n      }\n\n      this.eachLayer(map.removeLayer, map);\n\n   },\n\n\n})\n\n\nL.Map.include({\n\n   removeLayer: function (layer) {\n\n      var id = L.Util.stamp(layer);\n      \n      if (layer._arrowheads){\n         layer._arrowheads.remove()\n      }\n\n\t\tif (!this._layers[id]) { return this; }\n\n\t\tif (this._loaded) {\n\t\t\tlayer.onRemove(this);\n\t\t}\n\n\t\tif (layer.getAttribution && this.attributionControl) {\n\t\t\tthis.attributionControl.removeAttribution(layer.getAttribution());\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\tif (this._loaded) {\n\t\t\tthis.fire('layerremove', {layer: layer});\n\t\t\tlayer.fire('remove');\n\t\t}\n\n\t\tlayer._map = layer._mapToAdd = null;\n\n\t\treturn this;\n\t},\n\n})\n\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./node_modules/leaflet-arrowheads/src/leaflet-arrowheads.js?");

/***/ }),

/***/ "./node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Packaging/modules magic dance.\n(function (factory) {\n    var L;\n    if (true) {\n        // AMD\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! leaflet */ \"leaflet\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(function (L) {\n\"use strict\";\n\nL.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name L.GeometryUtil\n */\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\n        @tutorial distance-length\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n        var p = map.latLngToLayerPoint(latlng),\n           p1 = map.latLngToLayerPoint(latlngA),\n           p2 = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n        var isMetric = (unit !== 'imperial'),\n            distanceStr;\n        if (isMetric) {\n            // show metres when distance is < 1km, then show km\n            if (distance > 1000) {\n                distanceStr = (distance  / 1000).toFixed(2) + ' km';\n            }\n            else {\n                distanceStr = Math.ceil(distance) + ' m';\n            }\n        }\n        else {\n            distance *= 1.09361;\n            if (distance > 1760) {\n                distanceStr = (distance / 1760).toFixed(2) + ' miles';\n            }\n            else {\n                distanceStr = Math.ceil(distance) + ' yd';\n            }\n        }\n        return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n        tolerance = tolerance === undefined ? 0.2 : tolerance;\n        var hypotenuse = latlngA.distanceTo(latlngB),\n            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n        return delta/hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n        var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n        if (typeof coords.getLatLngs == 'function') {\n            coords = coords.getLatLngs();\n        }\n        if (coords.length === 0)\n            return [];\n        var total = 0,\n            lengths = [0];\n        for (var i = 0, n = coords.length - 1; i< n; i++) {\n            total += coords[i].distanceTo(coords[i+1]);\n            lengths.push(total);\n        }\n        return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var p = map.project(latlng, maxzoom),\n           p1 = map.project(latlngA, maxzoom),\n           p2 = map.project(latlngB, maxzoom),\n           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n        return map.unproject(closest, maxzoom);\n    },\n\n    /**\n        Returns the closest latlng on layer.\n\n        Accept nested arrays\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n\n        var latlngs,\n            mindist = Infinity,\n            result = null,\n            i, n, distance, subResult;\n\n        if (layer instanceof Array) {\n            // if layer is Array<Array<T>>\n            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n                // if we have nested arrays, we calc the closest for each array\n                // recursive\n                for (i = 0; i < layer.length; i++) {\n                    subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n                    if (subResult && subResult.distance < mindist) {\n                        mindist = subResult.distance;\n                        result = subResult;\n                    }\n                }\n                return result;\n            } else if (layer[0] instanceof L.LatLng\n                        || typeof layer[0][0] === 'number'\n                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n                layer = L.polyline(layer);\n            } else {\n                return result;\n            }\n        }\n\n        // if we don't have here a Polyline, that means layer is incorrect\n        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n        if (! ( layer instanceof L.Polyline ) )\n            return result;\n\n        // deep copy of latlngs\n        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n        // add the last segment for L.Polygon\n        if (layer instanceof L.Polygon) {\n            // add the last segment for each child that is a nested array\n            var addLastSegment = function(latlngs) {\n                if (L.Polyline._flat(latlngs)) {\n                    latlngs.push(latlngs[0]);\n                } else {\n                    for (var i = 0; i < latlngs.length; i++) {\n                        addLastSegment(latlngs[i]);\n                    }\n                }\n            };\n            addLastSegment(latlngs);\n        }\n\n        // we have a multi polygon / multi polyline / polygon with holes\n        // use recursive to explore and return the good result\n        if ( ! L.Polyline._flat(latlngs) ) {\n            for (i = 0; i < latlngs.length; i++) {\n                // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n                subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n\n        } else {\n\n            // Lookup vertices\n            if (vertices) {\n                for(i = 0, n = latlngs.length; i < n; i++) {\n                    var ll = latlngs[i];\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                    if (distance < mindist) {\n                        mindist = distance;\n                        result = ll;\n                        result.distance = distance;\n                    }\n                }\n                return result;\n            }\n\n            // Keep the closest point of all segments\n            for (i = 0, n = latlngs.length; i < n-1; i++) {\n                var latlngA = latlngs[i],\n                    latlngB = latlngs[i+1];\n                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n                if (distance <= mindist) {\n                    mindist = distance;\n                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n        var mindist = Infinity,\n            result = null,\n            ll = null,\n            distance = Infinity;\n\n        for (var i = 0, n = layers.length; i < n; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            } else {\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = {layer: layer, latlng: ll, distance: distance};\n                }\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n\n        @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n        n = typeof n === 'number' ? n : layers.length;\n\n        if (n < 1 || layers.length < 1) {\n            return null;\n        }\n\n        var results = [];\n        var distance, ll;\n\n        for (var i = 0, m = layers.length; i < m; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                results.push(subResult);\n            } else {\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                results.push({layer: layer, latlng: ll, distance: distance});\n            }\n        }\n\n        results.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n\n        if (results.length > n) {\n            return results.slice(0, n);\n        } else  {\n            return results;\n        }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n        }\n        else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance;  // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n            results.push({layer: layer, latlng: ll, distance: distance});\n        }\n      }\n\n      var sortedResults = results.sort(function(a, b) {\n          return a.distance - b.distance;\n      });\n\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n        withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n        var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n        if (!result || result.distance > tolerance)\n            return null;\n\n        // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n        if (withVertices && typeof result.layer.getLatLngs == 'function') {\n            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n            if (closest.distance < tolerance) {\n                result.latlng = closest;\n                result.distance = L.GeometryUtil.distance(map, closest, latlng);\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n        return L.point(\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\n        );\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n        var n = latLngs.length;\n        if (n < 2) {\n            return null;\n        }\n\n        // ensure the ratio is between 0 and 1;\n        ratio = Math.max(Math.min(ratio, 1), 0);\n\n        if (ratio === 0) {\n            return {\n                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n                predecessor: -1\n            };\n        }\n        if (ratio == 1) {\n            return {\n                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n                predecessor: latLngs.length - 2\n            };\n        }\n\n        // project the LatLngs as Points,\n        // and compute total planar length of the line at max precision\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var pts = [];\n        var lineLength = 0;\n        for(var i = 0; i < n; i++) {\n            pts[i] = map.project(latLngs[i], maxzoom);\n            if(i > 0)\n              lineLength += pts[i-1].distanceTo(pts[i]);\n        }\n\n        var ratioDist = lineLength * ratio;\n\n\t\t// follow the line segments [ab], adding lengths,\n        // until we find the segment where the points should lie on\n\t\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t\tvar pointA = pts[i], pointB = pts[i+1];\n\n\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\n\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\n\t\t}\n\t\t\n\t\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t\tvar pointA = pts[0], pointB = pts[1], i = 1;\n\t\t}\n\n\t\t// compute the ratio relative to the segment [ab]\n\t\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t\treturn {\n\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t\tpredecessor: i-1\n\t\t};\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n        var latlngs = polyline.getLatLngs();\n        if (latlng.equals(latlngs[0]))\n            return 0.0;\n        if (latlng.equals(latlngs[latlngs.length-1]))\n            return 1.0;\n\n        var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n            lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n            total_length = lengths[lengths.length-1],\n            portion = 0,\n            found = false;\n        for (var i=0, n = latlngs.length-1; i < n; i++) {\n            var l1 = latlngs[i],\n                l2 = latlngs[i+1];\n            portion = lengths[i];\n            if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n                portion += l1.distanceTo(point);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n        }\n        return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n        return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n        if (start > end) {\n            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n        }\n\n        // Bound start and end to [0-1]\n        start = Math.max(Math.min(start, 1), 0);\n        end = Math.max(Math.min(end, 1), 0);\n\n        var latlngs = polyline.getLatLngs(),\n            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        // Return single point if start == end\n        if (start == end) {\n            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n            return [point.latLng];\n        }\n        // Array.slice() works indexes at 0\n        if (startpoint.predecessor == -1)\n            startpoint.predecessor = 0;\n        if (endpoint.predecessor == -1)\n            endpoint.predecessor = 0;\n        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n        result.unshift(startpoint.latLng);\n        result.push(endpoint.latLng);\n        return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[lla.length-1]).equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[0]).equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs(),\n            start = lla[0];\n        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function(a, b) {\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function(a, b) {\n        var s = (b.y - a.y) / (b.x - a.x),\n            o = a.y - (s * a.x);\n        return {'a': s, 'b': o};\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var angleRad = angleDeg*Math.PI/180,\n            pPoint = map.project(latlngPoint, maxzoom),\n            pCenter = map.project(latlngCenter, maxzoom),\n            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n        return map.unproject(new L.Point(x2,y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function(latlng1, latlng2) {\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            lon1 = latlng1.lng * rad,\n            lon2 = latlng2.lng * rad,\n            y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n            x = Math.cos(lat1) * Math.sin(lat2) -\n                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n        return bearing >= 180 ? bearing-360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function(latlng, heading, distance) {\n        heading = (heading + 360) % 360;\n        var rad = Math.PI / 180,\n            radInv = 180 / Math.PI,\n            R = 6378137, // approximation of Earth's radius\n            lon1 = latlng.lng * rad,\n            lat1 = latlng.lat * rad,\n            rheading = heading * rad,\n            sinLat1 = Math.sin(lat1),\n            cosLat1 = Math.cos(lat1),\n            cosDistR = Math.cos(distance / R),\n            sinDistR = Math.sin(distance / R),\n            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n                sinDistR * Math.cos(rheading)),\n            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n        lon2 = lon2 * radInv;\n        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n        return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    },\n});\n\nreturn L.GeometryUtil;\n\n}));\n\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js?");

/***/ }),

/***/ "./src/react-leaflet-arrowheads.js":
/*!*****************************************!*\
  !*** ./src/react-leaflet-arrowheads.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-leaflet */ \"react-leaflet\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet_arrowheads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet-arrowheads */ \"./node_modules/leaflet-arrowheads/src/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar ArrowheadsPolyline =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ArrowheadsPolyline, _React$Component);\n\n  function ArrowheadsPolyline() {\n    _classCallCheck(this, ArrowheadsPolyline);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ArrowheadsPolyline).apply(this, arguments));\n  }\n\n  _createClass(ArrowheadsPolyline, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var polyline = this.polylineRef.leafletElement;\n\n      if (this.props.arrowheads) {\n        polyline.arrowheads(this.props.arrowheads);\n\n        polyline._update();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.props.arrowheads) {\n        var polyline = this.polylineRef.leafletElement;\n        polyline.deleteArrowheads();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_leaflet__WEBPACK_IMPORTED_MODULE_1__[\"Polyline\"], _extends({}, this.props, {\n        ref: function ref(polylineRef) {\n          return _this.polylineRef = polylineRef;\n        }\n      }), this.props.children);\n    }\n  }]);\n\n  return ArrowheadsPolyline;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ArrowheadsPolyline);\n\n//# sourceURL=webpack://ReactLeafletArrowheads/./src/react-leaflet-arrowheads.js?");

/***/ }),

/***/ "leaflet":
/*!************************************************************************!*\
  !*** external {"commonjs":"leaflet","commonjs2":"leaflet","root":"L"} ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet__;\n\n//# sourceURL=webpack://ReactLeafletArrowheads/external_%7B%22commonjs%22:%22leaflet%22,%22commonjs2%22:%22leaflet%22,%22root%22:%22L%22%7D?");

/***/ }),

/***/ "react":
/*!************************************************************************!*\
  !*** external {"commonjs":"react","commonjs2":"react","root":"React"} ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n\n//# sourceURL=webpack://ReactLeafletArrowheads/external_%7B%22commonjs%22:%22react%22,%22commonjs2%22:%22react%22,%22root%22:%22React%22%7D?");

/***/ }),

/***/ "react-leaflet":
/*!***********************************************************************************************!*\
  !*** external {"commonjs":"react-leaflet","commonjs2":"react-leaflet","Root":"ReactLeaflet"} ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_react_leaflet__;\n\n//# sourceURL=webpack://ReactLeafletArrowheads/external_%7B%22commonjs%22:%22react-leaflet%22,%22commonjs2%22:%22react-leaflet%22,%22Root%22:%22ReactLeaflet%22%7D?");

/***/ })

/******/ });
});